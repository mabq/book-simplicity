# First-class functions

## What does first-class mean?

First-class values can be:

1. Assign to variables
2. Pass as arguments to functions
3. Returned from functions
4. Stored in arrays or objects

In JavaScript functions are first-class values. Many other parts are not (arithmetic operators, for loops, if statements, try/catch blocks, etc), but we can wrap those parts with functions to make them first-class.

You canâ€™t have higher order functions without first-class functions.

## What are higher order functions?

Functions that take other functions as arguments, or that return a function, are called "higher order functions".

Higher order functions allow us better express the intent of the code and potentially eliminate duplication.

## Abstracting logic with data

> *Implicit argument in function name* is a code smell where the difference between functions is named in the function name.

We can apply a refactoring called *express implicit argument* to make the argument first-class instead of an inaccessible part of the function name. Here are the steps:

1. Identify the implicit argument in the name of the function
2. Add explicit argument
3. Use new argument in body in place of hard-coded value
4. Update the calling code

For example:

```javascript
// We can replace any number of functions like this...
function setPriceByName(cart, name, price) {}
function setQuantityByName(cart, name, quantity) {}
function setShippingByName(cart, name, shipping) {}

// With a generic function like this...
function setFieldByName(cart, name, field, value) {
    // pass 'price', 'quantity' or any other string as an argument to 'field'
}
```

### Will field names as strings lead to more bugs?

The fact that we can actually pass any string value to `field` makes us lose control over the object we are operating on. We have two options:

1. Compile-time checks â€” TypeScript would allow us to check that the strings belong to a known set of valid fields, runs once on compile time.
2. Run-time checks â€” check that the strings we pass in are valid, every time we run the function.

```javascript
var validItemFields = ['price', 'quantity', 'shipping', 'tax'];

function setFieldByName(cart, name, field, value) { 
    if(!validItemFields.includes(field)) {
        throw "Not a valid item field: " + "'" + field + "'.";
    }
    //...
}
```

### It's all strings on the wire!

The problem of strings goes much deeper than we often like to think. Our web browsers send JSON to the server. That JSON is just strings. The server will receive and parse it. The server hopes the message is well-formed JSON. If it is well formed, then we hope that the data structure is understandable.

The same goes for the web server talking to the database. The web server has to serialize the commands to the database into a string that gets serialized over the wire. The database has to parse and interpret it. Itâ€™s all strings on that wire, too. And even if there are types built into the data format, itâ€™s still just bytes â€” plenty of opportunity for typos or malicious behavior.

> An API must check data at runtime as it enters the server from a client, even if itâ€™s a static language. All the static type system can do is guarantee that the code in one piece of the system is consistent with the assumptions you encode as types.

Does that mean you shouldnâ€™t use static types? No. Does it mean you should? No. 

> You should just be aware that dynamic typing did not create this problem and static typing doesnâ€™t make it go away.
> 
> Weâ€™re seeing one downside of data: It requires interpretation.

### Will first-class fields make the API hard to change?

Letâ€™s say we needed to change `quantity` to `number` for some reason. We donâ€™t want to break all of the existing code, so we still have to accept `quantity`. We can just swap it out ourselves:

```javascript
var validItemFields = ['price', 'quantity', 'shipping', 'tax', 'number'];
var translations = { 'quantity': 'number' };

function setFieldByName(cart, name, field, value) { 
    if(!validItemFields.includes(field)) {
        throw "Not a valid item field: " + "'" + field + "'.";
    }
    if(translations.hasOwnProperty(field)) {
        field = translations[field];
    }
    //...
}
```

The field names we are exposing now as strings were all being exposed in the function names. But now we have the flexibility to change field names with a minor update.


## Abstracting logic with functions

> ðŸš€ &nbsp; Higher-order functions let us set up contexts for code defined elsewhere. The context becomes reusable because itâ€™s in a function.

In the JavaScript world, functions passed as arguments are often called *"callbacks"*. The function you are passing the callback to is expected to call it.

We can apply the refactoring called *"replace body with callback"* to abstract over behavior. It creates a first-class function argument that represents the behavioral difference between two functions. Here are the steps:

1. Identify the before, body, and after sections
2. Extract the whole thing into a function
3. Extract the body section into a function passed as an argument to that function

For example:

```javascript
// instead of writing many try/catch blocks like this...
try {
    saveUserData(user);
} catch (error) {
    logToSnapErrors(error);
}

// we can abstract the logic like this...
function withLogging(f) {
    try {
        f();
    } catch (error) {
        logToSnapErrors(error);
    }
}

// and the call it with an anonymous function like this
withLogging(() => saveUserData(user));
```

The reason we are passing in a function is so that the code in that function can be run in a particular context. Higher-order functions let you differ by code to execute (the callback) instead of just data.



