# Distinguishing actions, calculations and data

## Why?

Functional programming is all about **organizing side-effects** so that they don’t just occur anywhere.

Actions, calculations, and data are the first and most important distinction functional programmers make:

- Actions depend on time, so they are the hardest to get right, we separate them so we can devote more focus to them to make sure they happen in the right order.
- Calculations do not depend on time, so we want to write more code in this category because they are so easy to get right.
- Data is inert and require interpretation. Data is easy to understand, store, and transmit.

These categories correspond to how difficult the code is to understand, test, and reuse. The more code you extract from actions to calculations and data the simpler and more reliable it will be.

> 🚀 &nbsp; Always prefer data over calculations and calculations over actions

## Data

#### What is data? 

Data is facts about events. It is a record of something that happened. Functional programmers tap into the rich tradition of record-keeping that started thousands of years ago.

Immutable data flows from one calculation to the next — inputs and outputs, no hidden magic.

#### How do we implement data?

Using built-in data types — the JavaScript set of types consists of:

- *Primitive values* — immutable values represented directly at the lowest level of the language.
  - Boolean type
  - Null type
  - Undefined type
  - Number type
  - BigInt type
  - String type
  - Symbol type

- *Objects* — collections of properties (key-value pairs).

#### How does data encode meaning?

Data encodes meaning in structure. The structure of the data should mirror the structure of the problem domain you are implementing. For instance, if the order of a list of names is important, you should choose a data structure that maintains order.

Choosing the right data structure is critical for a straight forward implementation.

#### Why is immutable data so important?

> 🤓 &nbsp; It is impossible to write calculations on mutable data — mutable data implies time dependability

Let's see why:

- What happens when you pass a primitive value to a function? — operations inside will create new values (not mutate them), since those values are not accessible from outer scope no side-effects are created
- What happens when you pass an object to a function? — operations inside will effectively mutate the object, since that object is accessible from outer scope side-effects are created

Both, variables declared in outer scopes and variables declared in local scope point to the same addresses in memory, for more information read [how data, variables and scopes work](extras/data_variables_scopes.md).

#### How do we implement immutability in JavaScript?

> 🚀 &nbsp; Always use Immer to apply changes to objects

Never mutate data — *copy-on-write* is a discipline for ensuring immutability within code that we control. It requires *shallow-copies*.

Never let untrusted code access your data — *defensive copying* is a discipline for ensuring immutability with code that we don't control. It is expensive since it requires making *deep-copies* every time data leaves or enters our code.

Use a library — [Immer](https://github.com/immerjs/immer) is a tiny library that simplifies handling immutable data structures, its key benefits are:

1. Boilerplate reduction — less noise, more concise code
2. No new APIs or data structures
3. Structural sharing out of the box — better performance
4. Object freezing out of the box — more secure
5. Easy deep updates
6. No accidental mutations

While *defensive-copying* works by protecting the memory addresses of our mutable data, Immer works by making that mutable data immutable, so that it can be shared securely between shallow-copies or even with untrusted code.

#### Why data over calculations?

- Data is *serializable* — no problem being transmitted over a wire or stored to disk and read back later.
- Data is *comparable* — easily compare two pieces of data to see if they are equal or not.
- Data is *open for interpretation*.


## Calculations

#### What are calculations?

Calculations are computations from inputs to outputs — no matter when they are run, or how many times they are run, they will give the same output for the same inputs.

Break up the calculations as far as you need to. The more you break them up, the easier they become to implement. At some point, they are easy enough that the implementation becomes obvious. Breaking things into functions will pay off over time.

#### How do we implement calculations?

We represent calculations as functions with no implicit inputs and no implicit outputs. Implicit inputs are all of the inputs that aren’t arguments and implicit outputs are all of the outputs that aren’t the return value — both limit when you can call a function.

A function with implicit inputs and outputs is like a component hardwired to other components. It’s not modular. It can’t be used in another place. And its behavior depends on the behavior of the parts it’s connected to. By converting implicit inputs and outputs to explicit ones, we are making the component modular. Instead of solder, it’s got a connector that’s easy to detach.

#### How do calculations encode meaning?

Calculations encode meaning as computation. A calculation represents some computation from inputs to outputs. When or how you use it depends on whether that calculation is appropriate for the situation.

Calculations are *referentially transparent* because a call to a calculation can be replaced by its result and have an equivalent program — e.g. you can call `2 + 3` zero, one, or more times and get the same result.

#### Why prefer calculations over actions?

> 🔥 &nbsp; Time dependability is a big deal, it makes code much harder to reuse, test and maintain

Removing time dependability makes code so much easier to understand:

You can read the code and know what it is going to do. There’s a whole list of things you don’t have to worry about:

- What else is running at the same time
- What has run in the past and what will run in the future
- How many times you have already run it

They’re much easier to test. You can run them as many times as you want or wherever you want (local machine, build server, testing machine) in order to test them.

They’re very composable. Calculations can be put together into bigger calculations in very flexible ways. They can also be used in what are called “higher-order” calculations.

They’re much easier to maintain. Calculations are much more reliable, you can change everything but the function signature with affecting any other code.

They're ready for distributed systems. Most software written today is distributed. By moving more of our code into data and calculations, we sweep that code clean of the problems inherent in distributed systems.


## Actions

#### What are actions?

Actions are anything that have an effect on the world or are affected by the world. 

> 🤓 &nbsp; Actions depend on when or how many times they are run

Actions are a pain to deal with, but they are the reason we run our software in the first place.

> 🔥 &nbsp; Actions spread — we only have to identify one action inside a function for the whole function to be an action

#### How are actions implemented?

We use functions to implement actions.

#### How do actions encode meaning?

The meaning of an action is the effect it has on the world. We should make sure the effect it has is the one we want.

#### How to best deal with actions?

1. Use fewer actions if possible — we can never get all the way down to zero actions, but if an action isn’t required, use a calculation instead.
2. Keep your actions small — extract all calculations.
3. Restrict your actions to interactions with the outside — your actions are all of those things that are affected by the world outside or can affect the world outside. Inside, ideally, is just calculations and data.
4. Limit how dependent on time an action is — functional programmers have techniques for making actions a little less difficult to work with. These techniques include making actions less dependent on when they happen and how many times they are run.

#### How do we extract calculations from actions?

Extracting a calculation from an action is a repeatable process. Here are the steps.

1. Select and extract the calculation code — select a suitable chunk of code for extraction. Refactor that chunk into a new function. Add arguments where appropriate. Make sure to call the new function where the chunk was in the old function.
2. Identify the implicit inputs and outputs of the function.
3. Convert inputs to arguments and outputs to return values — you will need to assign the return value to a local variable in the original function. It’s important to note here that we want our arguments and return values to be immutable values. If we return a value and some piece of our function later changes it, that’s a kind of implicit output. Similarly, if something changes the argument values after our function has received them, that is a kind of implicit input.
